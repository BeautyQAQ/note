# Java面试题

## 1.Spring IOC, AOP, DI

### Spring IOC:

**什么是Spring IOC:**

- Spring IOC（控制反转）是一种设计模式和机制，它允许对象的创建和依赖注入控制被外部框架管理。在Spring中，IOC容器负责实例化和配置对象，并为它们提供它们所需依赖项。这有助于解耦组件，使代码更加模块化、易于测试和维护。
- 在Spring IOC中，开发人员不需要手动创建对象或解决它们的依赖关系，而是让Spring容器自动完成这些任务。开发人员只需要告诉Spring容器哪些类应该被实例化，并在需要注入它们所需的依赖项，因此大大简化了代码的编写和维护。
- Spring IOC有两种实现方式：XML配置和注解配置。XML配置是通过一个XML文件来描Bean及其依赖关系，而注解配置则是通过注解将Bean和它们的依赖关系显式地标识出来，加简洁和易于阅读。
- 总的来说，Spring IOC是Spring框架最核心的功能之一，也是实现松耦合、高内聚的要手段，提高了代码的可测试性和可维护性。

**创建 Spring IOC 容器的流程：**
    
- 配置 Spring 的核心配置文件。
- 加载配置文件并解析其中的 Bean 定义。
- 根据 Bean 定义创建并实例化 Bean。
- 将创建好的 Bean 注册到 Bean 容器中。
- 处理 Bean 之间的依赖关系，进行依赖注入。
- 提供 Bean 实例给应用程序使用。

    `在这个过程中，Spring IOC 容器会根据配置文件或者注解信息，自动识别、创建和管理各种 Bean，完成对象的实例化和依赖注入，最终提供这些 Bean 实例给应用程序使用。`

### Spring AOP:

    Spring AOP（面向切面编程）是一种编程范式，允许开发人员将应用程序中的横切关注点进行模块化。它通过提供一种方式来将应用程序的主要业务逻辑与其他行为（如日志记录、安全性或性能监控）分离出来，这些行为被称为切面。 Spring AOP使用代理类拦截方法调用，并在代码中的特定连接点应用方面。这种方法可以帮助开发人员减少代码重复，提高应用程序的可维护性和模块化程度。
    Spring框架提供了基于代理的AOP的实现方式，其核心是使用动态代理技术，在运行时动态地为目标对象创建代理对象，从而在代理对象中添加额外的逻辑。

### Spring DI

依赖注入（Dependency Injection, DI）是一种设计模式，也Spring框架的核心概念之一。其作用是去除Java类之间的依赖关系，实松耦合，以便于开发测试。为了更好地理解DI，先了解DI要解决的问题。[[1](https://zhuanlan.zhihu.com/p/67032669)]。  
在传统的Java开发中，对象之间存在着明显的依赖关系。比如对象A需要用对象B的某些方法或属性，那么对象A就必须自己去创建对象B，并维护象B的生命周期、状态等等。这样做有两个问题：

1. 对象之间的依赖关系非常紧密，一旦某个对象的代码发生变化，其所赖的其他对象的代码也可能需要进行修改。
2. 单元测试困难，无法独立测试某个对象，而必须测试整个依赖链。

通过依赖注入，我们可以将控制权交给容器，由容器去管理对象的创建和毁，同时也负责处理对象的依赖关系。这样做可以让对象之间的关系更散，减少代码的耦合度，提高代码的可维护性和重用性。具体实现方式包构造函数注入、Setter方法注入、接口注入等。Spring框架提供了各种现DI的工具，使得开发人员可以方便地实现依赖注入功能[[2](https:/zhuanlan.zhihu.com/p/67032669)]。

## 2.Spring

### Spring bean的生命周期

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化（相当于程序中的new Xx()）
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法(实现BeanNameAware接口主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的)
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入（（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等））
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。（(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanFactory前需要程序员自己指定（注入）setBeanFactory里的参数BeanFactory )
6. 如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）
7. 如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。
8. 如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果Bean实现了DisposableBean接口接口，Spring将调用它的destroy方法，作用与在配置文件中对Bean使用destroy-method属性的作用一样，都是在Bean实例销毁前执行的方法。

### spring mvc流程

1. 前端向服务器发送请求，请求被 Spring 前端控制Servlet DispatcherServlet(中央处理器)捕获；
2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回给DispatcherServlet(中央处理器)；
3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）
4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：  
HttpMessageConverter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息数据转换：对请求消息进行数据转换。如String转换成Integer、Double等数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中.
5. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
6. 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；
7. ViewResolver 结合Model和View，来渲染视图
8. 将渲染结果返回给客户端。

### Spring过滤器和拦截器

Spring的拦截器和过滤器都可以用于在请求进入控制器（Controller）之前或之后执行一些预处理或后处理操作。
其中，Spring的拦截器更加精细化，能够针对每个控制器或者控制器中的方法进行配置；而过滤器是基于Servlet API实现的，只能针对URL请求路径进行配置。此外，两者的执行顺序也不同：过滤器优先于拦截器执行，在请求进入Servlet容器时进行预处理；而拦截器是在请求进入Spring MVC的DispatcherServlet后才进行处理。最后，拦截器可以访问处理器上下文（HandlerContext），因此可以获取到更多和业务相关的信息，例如Session、用户信息等；而过滤器则不能。因此，在开发Spring应用时，建议优先选择拦截器来处理相关逻辑。[[1](https://blog.csdn.net/Herishwater/article/details/103544342)][[2](https://zhuanlan.zhihu.com/p/340397290)]

### Spring事物传播特性

    事务的传播，是指一个方法调用另一个方法并将事务传递给它。事务的转播机制主要针对被调用者而言，控制它是否被传播或者被怎样传播。Spring事务的传播机制有七种:

| 传播行为                  | 描述                                                                                                                              |
| :------------------------ | :-------------------------------------------------------------------------------------------------------------------------------- |
| PROPAGATION_REQUIRED      | 默认的Spring事物传播级别，若当前存在事务，则加入该事务，若不存在事务，则新建一个事务                                              |
| PROPAGATION_REQUIRE_NEW   | 若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交 |
| PROPAGATION_NESTED        | 如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务，类似于REQUIRE_NEW                                    |
| PROPAGATION_SUPPORTS      | 支持当前事务，若当前不存在事务，以非事务的方式执行                                                                                |
| PROPAGATION_NOT_SUPPORTED | 以非事务的方式执行，若当前存在事务，则把当前事务挂起                                                                              |
| PROPAGATION_MANDATORY     | 强制事务执行，若当前不存在事务，则抛出异常                                                                                        |
| PROPAGATION_NEVER         | 以非事务的方式执行，如果当前存在事务，则抛出异常                                                                                  |


Spring 事务在以下情况下可能会失效：

1. 非 Spring 管理的 Service 或 Dao 类中使用了事务注解，这种情况下，由于事务管理器并不知道这些类的存在，所以事务会失效。
2. 异常被 try-catch 捕获并处理后，没有抛出运行时异常或 Error，导致事务无法回滚。
3. 方法中创建了新的线程，新的线程中的事务不会被 Spring 管理。
4. 外部方法调用内部方法，内部方法的事务注解将会失效。
5. 事务的隔离级别设置不当，可能会导致数据不一致。
6. 事务的超时时间过短，可能导致事务执行失败。
7. 事务的传播特性设置不当，可能导致事务无法正常执行。
8. 在事务中使用 Hibernate 的 Session 和 SessionFactory，需要确保它们是与当前线程关联的。
9. 连接池闲置时间过长，导致数据库连接断开，从而事务失效。

以上是 Spring 事务可能失效的一些情况，需要根据实际情况进行分析和解决。

#### **Spring自定义注解如何实现**

Spring 中的自定义注解可以通过 Java 的反射技术来获取 Annotation 对象，在运行时对方法或者类进行动态设置。要自定义注解，需要使用 @interface 关键字声明一个注解，并为其添加相应的属性。示例代码如下：

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value() default "default";
}
```

以上代码定义了一个自定义注解 MyAnnotation , 该注解具有一个属性 value ，默认值为 "default" 。该注解可以标记在方法上，表示该方法需要被特殊处理。

然后可以在 Spring 的切面中使用该注解，以实现针对被标记方法的特殊处理。示例代码如下：

```java
@Aspect
@Component
public class MyAspect {

    @Around("@annotation(com.example.MyAnnotation)")
    public Object doSomething(ProceedingJoinPoint joinPoint) throws Throwable {
        // 处理逻辑
        return joinPoint.proceed();
    }

}
```

以上代码定义了一个切面 MyAspect ，其中通过 @Around 注解指定了切点表达式，这里使用了 "@annotation(com.example.MyAnnotation)" 以匹配带有 MyAnnotation 注解的方法。在处理逻辑 doSomething 中就可以根据 MyAnnotation 中定义的属性执行特定的操作。

[[2](https://zhuanlan.zhihu.com/p/60730622)][[1](https://spring.io/)]

### Spring Boot

#### **什么是Spring Boot**

Spring Boot是一个基于Spring框架的轻量级开发框架，可以快速构建可独立运行的、生产级别的Java应用。它采用了“约定大于配置”的理念，使得开发者只需很少的配置即可快速搭建一个基于Spring的应用程序。 

Spring Boot提供了起步依赖（Starters），这些依赖管理了类路径中不同的依赖库，简化了项目的构建和维护。同时，Spring Boot还提供了自动化配置（Auto-configuration）功能，通过分析项目的场景和配置，自动完成应用程序所需的各种配置工作。

在开发过程中，Spring Boot提供了一些非常实用的功能，例如内容协商、Web应用、数据访问、安全性和监控等功能，帮助开发者快速构建出高质量的应用程序。

可以通过[[1](https://spring.io/projects/spring-boot/)] 来了解更加详细的 Spring Boot 相关信息，而 [[2](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html)] 则提供了一个入门指南来快速入手 Spring Boot 的开发。

#### **Spring Boot启动流程**

Spring Boot的启动流程大致如下：

1. 通过main函数启动SpringApplication
    - 创建一个空的SpringApplicationContext对象
    - 解析并保存命令行参数
    - 设置应用程序初始上下文（如果指定了）
2. 根据当前环境和应用程序配置创建一个Environment对象
3. 载入所有可用的ApplicationContextInitializer，调用它们的initialize方法，将Environment传递给它们进行初始化 
4. 如果存在SpringApplicationRunListeners，则实例化并调用它们的starting()方法
5. 创建并配置ApplicationContext，包括：
    - 注册所有可用的BeanFactoryPostProcessor实现
    - 注册所有可用的BeanDefinitionRegistryPostProcessor实现
    - 扫描classpath，自动注册所有的bean
    - 注册默认的命名空间处理器
    - 初始化所有单例bean 
6. 如果存在SpringApplicationRunListeners，则实例化并调用它们的environmentPrepared()方法
7. 根据ApplicationContext创建SpringBootBanner
8. 如果存在SpringApplicationRunListeners，则实例化并调用它们的contextPrepared()方法
9. 刷新ApplicationContext，即进行必要的准备工作，例如初始化一些基础设施bean，注册事件监听器等
10. 如果存在SpringApplicationRunListeners，则实例化并调用它们的contextLoaded()方法
11. 启动web容器（如果需要），使应用程序成为一个独立运行的web应用程序 
12. 如果存在SpringApplicationRunListeners，则实例化并调用它们的started()方法
13. 向应用程序中注册所有可用的CommandLineRunner实现
14. 如果存在SpringApplicationRunListeners，则实例化并调用它们的running()方法

以上信息来源于：[[1](https://www.cnblogs.com/Narule/p/14253754.html)] 、[[2](https://zhuanlan.zhihu.com/p/301063931)] 。

#### **Spring Boot配置文件加密**

使用jasypt框架

## 3.设计模式

### 使用过那几种,具体的应用

### Spring中使用了哪些设计模式

## 4.MySQL

### MySQL索引

MYSQL索引是一种存储在MySQL数据库中的数据结构，用于加快对数据的检索速度。索引能够提高查询速度，减少查询所需的时间，增加系统的响应速度，并减轻对CPU和磁盘的负载压力。MYSQL索引的设计非常重要，它决定了整体的数据检索性能。

根据[[1](https://zhuanlan.zhihu.com/p/113917726)]，MYSQL索引的作用是实现快速检索，而这是由索引的存储形式和检索引擎的设计来决定的。而[[2](https://www.runoob.com/mysql/mysql-index.html)]则解释了合理使用SQL语句建立索引可以极大的提高MYSQL的查询速度。 合理的MYSQL索引设计和使用，不仅可以提高MYSQL的检索速度，还可以极大的提高系统的响应速度，降低系统出现故障或者宕机的风险。

MySQL索引的原理是基于数据结构和算法实现的。在MySQL中，索引是一种独立的数据结构，它通过对表中某列或多列数据进行排序，存储相应的键值和指向物理存储位置的指针，从而提高数据检索的效率。当查询语句需要访问表中的数据时，MySQL会根据查询条件从索引中查找所需的数据，而不是直接扫描全表，从而极大地提高了检索速度。

MySQL索引的实现原理基于B-Tree和Hash算法，其中B-Tree算法是最常用的索引算法。B-Tree索引采用树形结构来对数据进行排序，并且可以快速定位和访问特定的节点。当数据被加入到B-Tree中时，MySQL会根据其键值将其插入到相应的节点中，从而保证节点中数据的有序性。这样，当需要搜索特定值时，MySQL只需遍历树上最多几个节点即可定位到该值，并返回其指针，从而实现了快速检索。

除了B-Tree索引，MySQL还支持Hash索引、全文索引等多种索引类型。不同的索引类型适用于不同的场景，具体的选择需要根据实际情况进行权衡。

### SQL优化

1. SQL的执行次数分析:  
SQL: show global status like 'com_______'，解释:通过该命令可以查看当前数据库下的增删改查的使用次数,来采取对应的优化处理. value值就是执行的次数。比如替换不同的存储引擎
2. 慢查询日志:
SQL: show variables like '%slow_query_log%'; 慢查询日志会记录超出自己设置的时间还没有执行完毕的sql. 默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。  
开启慢查询日志SQL: set global slow_query_log=1; 使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf  
设置慢查询的超时时间: set global long_query_time=2; 以秒为单位  

3. 使用explain关键字来查看当前SQL语句的执行情况,来对症下药.explain是非常重要的关键字,要善于运用它.通过explain我们可以获得以下信息：
    - 表的读取顺序
    - 数据读取操作的操作类型
    - 哪些索引可以使用
    - 哪些索引被实际使用
    - 表之间的引用
    - 每张表有多少行被优化器查询

4. 正确的建立和使用索引
    - 经常需要搜索的列上，可以加快搜索的速度；
    - 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
    - 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
    - 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
    - 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
    - 避免 where 子句中对字段施加函数，这会造成无法命中索引。
    - 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
    - 删除长期未使用的索引

5. 对SQL语句进行优化
    - SQL语句中IN包含的值不应过多
    - SELECT语句务必指明字段名称
    - 只查询一条数据的时候，使用limit 1
    - 避免在where子句中对字段进行null值判断: 对于null的判断会导致引擎放弃使用索引而进行全表扫描。mysql会自动判断数据的分布情况，判断数据中 null 多还是 not null 多, 然后决定走不走索引. 
    - 避免在where子句中对字段进行表达式操作
    - 对于联合索引来说，要遵守最左前缀法则
    - 尽量使用inner join，避免left join：如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表（所以如果要使用left join，则要小表驱动大表）。
    - 注意范围查询语句: 对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失效。解决办法: 业务允许的情况下,使用 >= 或者<=  这样不影响索引的使用. 当MySQL发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描。
    - 不建议使用%前缀模糊查询:例如 : LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。
    - 在 where 子句中使用 or 来连接条件，如果or连接的条件有一方没有索引,将导致引擎放弃使用索引而进行全表扫描。解决办法: 将or连接的双方都建立索引,就可以使用. 
    - 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。(此处存在疑点,测试的时候,发现索引还是能使用到)
    - 字符串类型的字段 查询的时候如果不加引号''  ,会导致自动进行隐式转换,然后索引失效
    - 指定查询的索引，当SQL查询的字段有多个索引的时候,MySQL优化器会自动选择一个索引进行查询,我们也可以通过SQL字段进行自定义

6. 其他优化
    - 需要插入多条数据的时候 使用批量插入.(多次插入需要频繁的建立连接.浪费资源) 
    - 多次插入数据时,采用手动提交事务
    - order by 排序优化 (排序时,使用有索引的字段进行排序) 
    - count 优化，速度:count(*)>count(1)>count(字段)，count( * ):innoDB引擎,特意做了优化,不会取出值,直接服务层进行累加
    - update优化  (避免出现表锁)，innoDB引擎使用update时,会有行锁/表锁两种模式, 如果where 字段没有索引的时候会升级成表锁
    - 创建表时使用统一的编码，mysql多表联查时,如果表的字符集不一样,会有一个数据类型转换的过程. 例如 utf8 与utf8mb4前者是3字节unicode编码，后者是4字节unicode编码. 此时如果多表查询,则索引会失效

### 乐观锁和悲观锁

**悲观锁:** 假定数据并发冲突,屏蔽一切可能违法数据完整性的操作,在查询数据完就把事务锁起来,知道提交事务

**乐观锁:** 假定不会发生并发冲突,只在提交时检查是否违反数据完整性,在修改数据的时候吧事务锁起来,通过version来锁定,实现方式:一般使用版本号或者cas算法来实现

## 5.分布式

### 分布式的CAP理论

CAP理论是指分布式系统中三个核心概念之间的平衡关系：一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）。CAP理论认为，在分布式系统中，无法同时满足这三个目标，只能在它们之间进行权衡或者选择其中的两个来保证分布式系统的正常运行。

一致性是指分布式系统中的数据始终保持同步和正确性。在一个满足强一致性要求的系统中，任何时刻任何节点读取到的数据都是一致的。可用性是指系统必须在几乎所有的请求中都能够返回合适的响应结果。在一个满足高可用性要求的系统中，系统的响应速度和可用性非常高，但是这可能会导致数据的不一致性。分区容错性是指分布式系统中的某些节点可能由于网络故障、硬件问题等原因丢失连接，但是整个系统仍然能够继续运作。

根据CAP理论，分布式系统只能同时满足其中的两个要求，并且必须牺牲另一个目标。例如，在保证一致性和分区容错性的前提下，可用性可能会受到一定程度的影响。在实际应用中，需要根据系统的需求和实际情况来选择其中的两个目标权衡。

### 分布式锁

    使用redis的分布式锁。具体做法是后端接收到请求后加入一个分布式锁，如果加锁成功，就执行业务，如果加锁失败就等待锁或者拒绝请求。业务执行完成后释放锁。

使用的是SETNX命令：`SETNX KEY_NAME VALUE`。设置成功返回1，设置失败返回0

1. 如果加锁成功的客户端挂了怎么办？
   可以设置一个过期时间，命令：`SET key value [EX seconds] [PX milliseconds] NX`
2. 设置了过期时间，如果业务还没有执行完成，但是redis锁过期了，怎么办？
   需要对锁进行续约。设置锁成功后，启动一个watchdog，每隔一段时间(比如10s)为当前分布式锁续约，也就是每隔10s重新设置当前key的超时时间。`EXPIRE <key> <seconds>`
3. watchdog怎么实现呢？
   当客户端加锁成功后，可以启动一个定时任务，每隔10s(最好支持配置)来检测业务是否处理完成，检测的依据就是判断分布式锁的key是否还存在，如果存在，就进行续约。
4. 如果当前线程已经处理完，这个key是被其他客户端写入的呢？
   可以为每个客户端指定一个clientID，在VALUE中增加一个clientID的前缀，这样在续锁的时候，可以判断当前分布式锁的value前缀来确定是不是当前客户端的，如果是再续锁，否则不做处理。
5. 如果client1宕机了，这时分布式锁还可以续期吗？
   因为分布式锁的续期是在客户端执行的，所以如果client1宕机了，续期线程就不能工作了，也就不能续期了。这时应该把分布式锁删除，让其他客户端来获取。
6. 那如果client1宕机了，其他客户端需要等待30s才能有机会获取到锁，有办法立刻删除锁吗？
   因为client1宕机了，只能等到超时时间后锁被自动删除。如果要立刻删除，需要增加额外的工作，比如增加哨兵机制，让哨兵来维护所有redis客户端的列表。哨兵定时监控客户端是否宕机，如果检测到宕机，立刻删除这个客户端的锁。这里的哨兵并不是redis的哨兵，而且为了检测客户端故障业务系统自己做的哨兵。

### 如何保证数据库和缓存的一致性

- 先删除缓存，再更新数据库需要用到延迟双删策略，并发场景下的延迟双删策略，这个延迟时间很难评估，所以推荐【先更新数据库，再删除缓存】的方案，这个方案一般来说更新数据库会比查询更慢，所以这个删除操作理论上会在查询线程的后面进行，会大大降低出现一致性问题的概率。
- 在【先更新数据库，再删除缓存】的方案下，为了保证两步都能执行成功，需要配合【消息队列】或【订阅变更日志】的方案来做，其本质是通过重试的方式保证数据一致性。
- 在【先更新数据库，再删除缓存】方案下，【读写分离 + 主从延迟】也会导致缓存和数据库不一致，解决问题的方案是【延迟双删】，凭借经验发送【延迟消息】到队列中，延迟删除缓存，同时要也要控制主从库延迟（可以通过暂时剔除延迟高的节点，延迟低的时候再将节点加入集群），尽可能降低不一致发生的概率。
- 如果要保证强一致性，可以将mysql的update 和delete redis的操作放到一个分布式锁中，redis get 操作如果获取到的数据为null，则使用分布式锁锁住然后查询mysql获取最新的值，确保更新，删除，查询三个操作在同一个锁中完成，简单的代码大概这样：
```
redis.lock()
delete redis;
update mysql;
redis.unlock;

object o=redis.get();
if(o==null){
    while(!redis.isLock()){
        select mysql;
        redis.set();
    }
}
```

## 6.JVM

### jvm参数调优

1. jvm调优涉及到两个很重要的概念：吞吐量和响应时间。jvm调优主要是针对他们进行调整优化，达到一个理想的目标，根据业务确定目标是吞吐量优先还是响应时间优先。  
吞吐量：用户代码执行时间/(用户代码执行时间+GC执行时间)。  
响应时间：整个接口的响应时间(用户代码执行时间+GC执行时间)，stw时间越短，响应时间越短。  

    调优的前提是熟悉业务场景，先判断出当前业务场景是吞吐量优先还是响应时间优先。调优需要建立在监控之上，由压力测来判断是否达到业务要求和性能要求。  调优的步骤大致可以分为：
   - 熟悉业务场景，了解当前业务系统的要求，是吞吐量优先还是响应时间优先；
   - 选择合适的垃圾回收器组合，如果是吞吐量优先，则选择ps+po组合；如果是响应时间优先，在1.8以后选择G1，在1.8之前选择ParNew+CMS组合；
   - 规划内存需求，只能进行大致的规划。
   - CPU选择，在预算之内性能越高越好；
   - 根据实际情况设置升级年龄，最大年龄为15；
   - 设定日志参数：-Xloggc:/path/name-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogs=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCauses
 
```txt
-XX:+UseGCLogFileRotation：GC文件循环使用
-XX:NumberOfGCLogs=5：使用5个GC文件
-XX:GCLogFileSize=20M：每个GC文件的大小
上面这三个参数放在一起代表的含义是：5个GC文件循环使用，每个GC文件20M，总共使用100M存储日志文件，当5个GC文件都使用完毕以后，覆盖第一个GC日志文件，生成新的GC文件。
```

2. 对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。导致Full GC的原因一般是年老代（Tenured）被写满，调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在年老代创建对象。

    - 1.监控GC的状态
    - 2.生成堆的dump文件，通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。
    - 3.分析dump文件，Visual VM
    - 分析结果，判断是否需要优化，如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

### 垃圾收集器

JDK8中默认的是UseParallelGC 即 Parallel Scavenge + Parallel Old

[参考资料](https://blog.csdn.net/xushiyu1996818/article/details/102761595)

#### **Serial 收集器**

这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收 集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（这件事情称之为“Stop The World”），直到它收集结束.**新生代采用标记-复制算法，老年代采用标记-整理算法。**

特点是简单而高效（与其他收集器的单线程比），对 于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收 集自然可以获得最高的单线程收集效率。

#### **ParNew 收集器**

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数。**新生代采用标记-复制算法，老年代采用标记-整理算法。**

其中有一个与功能、性能无关但其实很重要的原因是:除了Serial收器外,目前只有它能与CMS收集器配合工作。自JDK 9开始，可以理解为ParNew合并入CMS,成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。

#### **Parallel Scavenge 收集器**

Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器， 又是并行的多线程收集器（**新生代采用标记-复制算法，老年代采用标记-整理算法。**）, Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目 标则是达到一个可控制的吞吐量(Throughput)。  

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量 优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参 数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就 不需要手工指定新生代的大小（・Xmn）、Eden与Survivor区的比例（・XX:SurvivorRatio）、 晋升老年代对象年龄（・XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当 前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或 最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）

#### **CMS收集器**

CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字(包含“MarkSweep”)上就可以看出CMS收集器是基于“标记-清除”算 法实现的.

CMS运作过程:
- 初始标记(CMS initial mark)
- 并发标记(CMS concurrent mark)
- 并发预清理
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。

CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、 低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器(Concurrent Low Pause Collector)。但是CMS还远达不到完美的程度，它有以下四个显著的缺点：

- 对 CPU 资源敏感
- 无法处理浮动垃圾，可能会导致serial old
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生
- 需要预留的空间，给用户线程使用

#### **G1收集器**

G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

作为CMS收集器的替代者和继承人,设计者们希望做出一款能够建立起“停顿时间模型” (PausePrediction Model)的收集器,停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标,这几乎已经是实时Java (RTSJ)的中软实时垃圾收集器特征了。  
在G1收集器出现之前的所有其他收集器,包括CMS在内,垃圾收集的目标范围要么是整个新生代(Minor GC) ,要么就是整个老年代(Major GC) ,再要么就是整个Java堆(Full GC)。而G1跳出了这个樊笼,它可以面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。

G1 收集器采用一种不同的方式来管理堆内存.堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。

### **ZGC收集器**

ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：
- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。
- 从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。
- 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

## 7.netty

### netty的线程模型

## 8.流量网关

### sentinel

**sentinel核心**

- 1.资源(服务,接口,方法,链路)
- 2.规则(限流的判断规则),总的并发数,并发的线程数量

流量控制后的处理方法

- 1.抛异常
- 2.排队
- 3.降级

限流规则由下面几个因素组成

- resource:资源名,即限流规则的对象  
- count:限流阀值  
- grade:限流阀值的裂类型(QPS,或者并发线程数)  
- limitAPP:流控的针对的调用来源 若为default则不区分来源  
- strategy:限流规则  
- controlBehavior:流量控制的效果(直接拒绝,warm up(冷启动),匀速排队)

**QPS流量控制**  

1. 直接拒接

    直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当 QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。 这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。

2. Warm Up

    Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系 统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压 垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预 热的时间，避免冷系统被压垮。

    以下都会随着系统访问量增加逐步预热来提升性能的因素.  

    - 缓存预热 
    - 数据库连接池初始化

    `可以设置预热的时间`

3. 匀速排队

    匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过 的间隔时间，也即是让请求以均匀的速度通过，其实对应的是漏桶算法。 当请求数量远远大于阈值时，这些请求会排队等待，这个等待时间可以设置，如果超过等待时间，那这个请求会被拒绝。

4. 熔断降级

    当访问量比较高的请求下，一个后端依赖节点的延迟响应可能导致所有服务器上的所有资源在 数秒内饱和。一旦出现这个问题，会导致系统资源被快速消耗，从而导致服务宕机等问题，最坏的情况会导致服务雪崩

    所以在软件系统中，为了防止这种问题的产生，也引入了熔断的概念。所以，熔断的意义是： 如果某个目标服务调用比较慢或者大量的超时，这个时候如果触发熔断机制，则可以保证后续 的请求不会继续发送到目标服务上，而是直接返回降级的逻辑并且快速释放资源。如果目标服务的情况恢复了，那么熔断机制又会动态进行关闭。

如何判定资源不稳定呢？

1. 慢调用比例（SLOW_REQUEST_RATIO）。 
2. 异常比例（ERROR_RATIO）。 
3. 异常数（ERROR_COUNT）

**动态流控**  

我们可以通过Sentinel Dashboard或者Config CenterDashboard把流控规则推送到统一的配置中心（Nacos、Zookeeper等），客户端通过实现 ReadableDataSource接口来监听配置中心，从而实时获取变更的规则实现动态控制。

**DataSource 扩展常见的实现方式有:**

拉模式：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件，甚至是 VCS 等。这样做的方式是简单，缺点是无法及时获取变更； 

推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。

## 9.Java基础

### java四大特性

### 静态变量和普通变量的区别

### 说说工作中用到的设计模式，我背了个代理模式

## 10.多线程

### 获取线程返回结果

可以通过使用Java的Future对象来获取线程执行的结果。在多线程执行任务时，可以将任务封装成实现了Callable接口的类，并用FutureTask类来包装该类的对象。FutureTask类实现了Runnable接口，因此它可以作为一个线程来执行。在主线程中，可以先调用FutureTask的get()方法来获取任务执行的结果。如果任务尚未完成，主线程会阻塞等待。当任务完成后，主线程就可以拿到任务的返回值。

参考知识来源链接：[[1](https://www.cnblogs.com/coder-programming/articles/11955844.html)]

或者使用`CompletableFuture`:

`CompletableFuture` 是 Java 8 引入的异步编程工具，它基于 `Future` 和 `Promise` 设计实现。与传统的 `Future` 相比，`CompletableFuture` 提供了更好的异步编程体验。在 Java 9 中，`CompletableFuture` 进一步增强，并提供了更多的方法支持，使得 Java 的异步编程变得更加简单和便捷。

`CompletableFuture` 可以被显式地完成(通过设置其值和状态)，并且可以用作 CompletionStage，支持依赖函数和在其完成时触发的操作。当两个或多个线程尝试完成、completeExceptionally 或取消 CompletableFuture 时，只有一个线程成功。除了这些直接操纵状态的方法之外，还有一些其他方法可用于组合和转换 CompletableFuture。

Java 9 为 `CompletableFuture` 提供了一些新特性，如超时和延迟支持、更好的继承支持和实用工具方法等。在代码方面，API 增加了八个新方法和五个新的静态方法。

参考知识来源链接：[[1](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)][[2](https://www.baeldung.com/java-9-completablefuture)]


`CompletableFuture` 的使用方法如下：

1. 创建 `CompletableFuture` 对象。可以使用 `CompletableFuture.supplyAsync()` 或者 `CompletableFuture.runAsync()` 方法创建一个异步任务，这些方法会返回一个已经启动了的 `CompletableFuture` 对象。

2. 添加回调函数。通过 `thenApply()`, `thenAccept()`, `thenRun()`, `thenCompose()`, 或 `thenCombine()` 等方法，将原始 `CompletableFuture` 对象与一个回调函数关联起来，使得在 `CompletableFuture` 对象执行完毕后，将会自动执行回调函数。

3. 组合多个 `CompletableFuture` 对象。通过 `allOf()` 或者 `anyOf()` 方法，可以将多个 `CompletableFuture` 对象组合起来进行并发操作，从而加速程序的执行。

4. 能够让主线程等待 `CompletableFuture` 完成。`CompletableFuture` 对象的 `join()` 方法能够让主线程等待当前 `CompletableFuture` 对象执行完成，从而避免了使用 `get()` 方法时可能产生的异常抛出。

下面是一个简单的 `CompletableFuture` 的例子：

```
CompletableFuture.supplyAsync(() -> "Hello World")
    .thenApply(s -> s + " - CompletableFuture")
    .thenAccept(System.out::println)
    .join();
```
在这个例子中，我们创建了一个新的 `CompletableFuture` 对象，并通过 `thenApply()` 方法将其与一个回调函数关联起来。回调函数处理字符串拼接操作，之后通过 `thenAccept()` 方法将回调函数的结果打印出来。最后通过 `join()` 方法等待 `CompletableFuture` 对象执行完毕。

参考知识来源链接：[[1](https://www.baeldung.com/java-completablefuture)]

### 线程生命周期

线程的生命周期包括五个阶段：

1.新建状态(New): 当一个线程对象被创建后，它处于新建状态。此时它已经拥有了代码运行所需的所有资源，但还没有开始执行。

2.就绪状态(Ready): 线程一旦进入就绪状态，就表示它已经准备好了运行，只要CPU有时间，它随时可以开始执行。

3.运行状态(Running): 线程进入运行状态后，CPU开始执行线程的代码。

4.阻塞状态(Blocked): 当线程需要等待某个条件满足时，比如等待IO操作完成，它会进入阻塞状态。此时它不会占用CPU时间片，直到等待的条件满足后才会进入就绪状态。

5.终止状态(Terminated): 当线程的run()方法执行完毕时，它就进入终止状态。线程一旦进入这种状态，就表示它已经完成了自己的使命，不再需要运行。[[1](https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B/103101)]

## 11.其他

### http接口的内容

### 层网络模型

应用层->表示层->会话层->传输层->网络层->数据链路层->物理层

### sharding-jdbc多主多从配置 主从如何进行数据同步

### 为什么选择sharding-jdbc进行分库分表的一个设计 

当前的技术选型有二种,一种是mycat,一个是sharding-jdbc,mycat 基于proxy内存实现mysql协议,可以当做数据库来使用,sharding-jdbc基于jdbc的一个增强,性能高

### 线上定位问题调试

通过日志，做好日志打印，方便各种问题调试

### 2.死锁、如何避免死锁

死锁是指二个或多个事务在同一资源上相互占用,并请求锁定对方的资源,从而导致恶性循环  

**解决死锁的方法:**

- 1.如果不同程序并发存取多张表,尽量以约定相同的顺序访问表,可大大降低死锁
- 2.在同一个事务中,尽可能的一次锁全部的资源,减少锁产生的概率
- 3.对于非常容易产生死锁的业务部分,可能尝试使用升级锁定的粒度,通过表锁来减少锁产生的概率
- 4.如果业务不好处理,可以采用分布式事务锁,或者乐观锁

### 如何找出热点缓存数据

在业务表中增加一个字段，查询一次标记一次，次数到达一定值之后作为热点数据，在业务逻辑中处理。

### 使用的什么流水线部署, Jenkins, GitHub Actions

### 项目遇到的问题

- 1.要配置熔断器的超时时间，否则默认时间是1s，很容易报错
- 2.用来传输数据的result类要有一个默认的构造函数，否则会有一个类型定义错误

## 12.场景题

### 30w数据，每个数据30个标签，需要筛选，怎么设计表

大对象变小如何存入redis

Kafka和rabbit分别实现多消费者

项目难点

多线程参数，超时时间

延时任务用哪个线程池

spring cloud Alibaba套件

open feign

负载均衡

面试题笔试题回答上来的有大概以下:谈一谈OOP，详细说一下数据类型，谈一谈继承、多态，谈一谈接口和抽象类的区别，三目运算符，
说一下六个设计原则，说几个会的设计模式及应用场景，手写单例模式（线程安全），手写冒泡排序、快速排序，聊一聊集合框架（问的很多，涉及底层实现），
手写实现文件的复制，介绍一下多线程（主要是不同的创建方式及其相关概念），Mysql相关概念及其优化（索引问得多），Servlet生命周期，jsp的9个内置对象，
filter的配置及应用，Spring的IOC和DI，AOP，Struts2、Spring、SpringMVC的工作流程及其配置文件，Spring及Spring boot的相关注解，
MyBatis和Hibernate的不同点及各自优缺点。以上是知识点，临场表达能力就靠自己了。        
以下是没有回答上来的：谈一谈JVM，笛卡儿积，红黑树的实现，nio，Linux搜索空文件夹并在每个文件夹中创建制定文件，
Sql语句也有很多写不出来，前端框架会多少，

喜欢那些新技术



<!-- 面试历程: 
腾讯外包 -- 寄
尤尼信息 -- 过
众鼎（平安外包） -- 过
机大呷 -- 寄
鑫泉网络 -- 寄
租客网 -- 寄
云台一号 -- 寄
南山医疗公司（基本没问啥） -- 寄
南方电网的笔试题 -- 寄
金贝塔 -- 过
赣州银行外包面 -- 过
宽拓外包 -- 等待中 -->