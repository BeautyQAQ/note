**1.死锁 如何避免死锁**

死锁是指二个或多个事务在同一资源上相互占用,并请求锁定对方的资源,从而导致恶性循环
解决死锁的方法:

- 1.如果不同程序并发存取多张表,尽量以约定相同的顺序访问表,可大大降低死锁
- 2.在同一个事务中,尽可能的一次锁全部的资源,减少锁产生的概率
- 3.对于非常容易产生死锁的业务部分,可能尝试使用升级锁定的粒度,通过表锁来减少锁产生的概率
- 4.如果业务不好处理,可以采用分布式事务锁,或者乐观锁

**2.spring ioc,aop,di,你具体使用了那种**

**3.spring设计模式,你使用过那几种,具体的应用**

**4.mysql 乐观锁,悲观锁**

悲观锁:假定数据并发冲突,屏蔽一切可能违法数据完整性的操作,在查询数据完就把事务锁起来,知道提交事务

乐观锁:假定不会发生并发冲突,只在提交时检查是否违反数据完整性,在修改数据的时候吧事务锁起来,通过version来锁定,实现方式:一般使用版本号或者cas算法来实现

**5.netty的线程模型**

**6.http接口的内容**

**7.7层网络模型**

应用层->表示层->会话层->传输层->网络层->数据链路层->物理层

**8.sharding-jdbc多主多从配置 主从如何进行数据同步**

**9.为什么选择sharding-jdbc进行分库分表的一个设计** 

当前的技术选型有二种,一种是mycat,一个是sharding-jdbc,mycat 基于proxy内存实现mysql协议,可以当做数据库来使用,sharding-jdbc基于jdbc的一个增强,性能高

**10.sentinel核心**

1. 资源(服务,接口,方法,链路)
2. 规则(限流的判断规则),总的并发数,并发的线程数量

流量控制后的处理方法
1. 抛异常
2. 排队
3. 降级

限流规则由下面几个因素组成
- resource:资源名,即限流规则的对象  
- count:限流阀值  
- grade:限流阀值的裂类型(QPS,或者并发线程数)  
- limitAPP:流控的针对的调用来源 若为default则不区分来源  
- strategy:限流规则  
- controlBehavior:流量控制的效果(直接拒绝,warm up(冷启动),匀速排队)

**QPS流量控制**  

1.直接拒接  
直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当 QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。 这种方式适用于对系统处理能力确切已知的情况下，比如通过压测确定了系统的准确水位时。

2.Warm Up  
Warm Up（RuleConstant.CONTROL_BEHAVIOR_WARM_UP）方式，即预热/冷启动方式。当系 统长期处于低水位的情况下，当流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压 垮。通过"冷启动"，让通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，给冷系统一个预 热的时间，避免冷系统被压垮。

以下都会随着系统访问量增加逐步预热来提升性能的因素.  
- 缓存预热 
- 数据库连接池初始化

可以设置预热的时间

3.匀速排队    
匀速排队（RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER）方式会严格控制请求通过 的间隔时间，也即是让请求以均匀的速度通过，其实对应的是漏桶算法。 当请求数量远远大于阈值时，这些请求会排队等待，这个等待时间可以设置，如果超过等待时 间，那这个请求会被拒绝。

4.熔断降级  
当访问量比较高的请求下，一个后端依赖节点的延迟响应可能导致所有服务器上的所有资源在 数秒内饱和。一旦出现这个问题，会导致系统资源被快速消耗，从而导致服务宕机等问题，最坏的情况会导致服务雪崩

所以在软件系统中，为了防止这种问题的产生，也引入了熔断的概念。所以，熔断的意义是： 如果某个目标服务调用比较慢或者大量的超时，这个时候如果触发熔断机制，则可以保证后续 的请求不会继续发送到目标服务上，而是直接返回降级的逻辑并且快速释放资源。如果目标服务的情况恢复了，那么熔断机制又会动态进行关闭。

如何判定资源不稳定呢？
1. 慢调用比例（SLOW_REQUEST_RATIO）。 
2. 异常比例（ERROR_RATIO）。 
3. 异常数（ERROR_COUNT）


动态流控  
我们可以通过Sentinel Dashboard或者Config CenterDashboard把流控 规则推送到统一的配置中心（Nacos、Zookeeper等），客户端通过实现 ReadableDataSource接口来监听配置中心，从而实时获取变更的规则实现动态控制。

DataSource 扩展常见的实现方式有: 

拉模式：客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是 RDBMS、文件，甚至是 VCS 等。这样做的方式是简单，缺点是无法及时获取变更； 

推模式：规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用 Nacos、Zookeeper 等配置中心。这种方式有更好的实时性和一致性保证。

**如何保证数据库和缓存的一致性**

- 先删除缓存，再更新数据库需要用到延迟双删策略，并发场景下的延迟双删策略，这个延迟时间很难评估，所以推荐【先更新数据库，再删除缓存】的方案，这个方案一般来说更新数据库会比查询更慢，所以这个删除操作理论上会在查询线程的后面进行，会大大降低出现一致性问题的概率。
- 在【先更新数据库，再删除缓存】的方案下，为了保证两步都能执行成功，需要配合【消息队列】或【订阅变更日志】的方案来做，其本质是通过重试的方式保证数据一致性。
- 在【先更新数据库，再删除缓存】方案下，【读写分离 + 主从延迟】也会导致缓存和数据库不一致，解次问题的方案是【延迟双删】，凭借经验发送【延迟消息】到队列中，延迟删除缓存，同时要也要控制主从库延迟（可以通过暂时剔除延迟高的节点，延迟低的时候再将节点加入集群），尽可能降低不一致发生的概率。
- 如果要保证强一致性，可以将mysql的update 和delete redis的操作放到一个分布式锁中，redis get 操作如果获取到的数据为null，则使用分布式锁锁住然后查询mysql获取最新的值，确保更新，删除，查询三个操作在同一个锁中完成，简单的代码大概这样：
```
redis.lock()
delete redis;
update mysql;
redis.unlock;

object o=redis.get();
if(o==null){
    while(!redis.isLock()){
        select mysql;
        redis.set();
    }
}
```

**sql优化**、

1.sql的执行次数分析:  
sql: show global status like 'com_______'，解释:通过该命令可以查看当前数据库下的增删改查的使用次数,来采取对应的优化处理. value值就是执行的次数。比如替换不同的存储引擎
2.慢查询日志:
sql: show variables like '%slow_query_log%'; 慢查询日志会记录超出自己设置的时间还没有执行完毕的sql. 默认情况下，Mysql数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。  
开启慢查询日志sql: set global slow_query_log=1; 使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf  
设置慢查询的超时时间: set global long_query_time=2; 以秒为单位  

3.使用explain关键字来查看当前sql语句的执行情况,来对症下药.explain是非常重要的关键字,要善于运用它.通过explain我们可以获得以下信息：
- 表的读取顺序
- 数据读取操作的操作类型
- 哪些索引可以使用
- 哪些索引被实际使用
- 表之间的引用
- 每张表有多少行被优化器查询

4.正确的建立和使用索引
- 经常需要搜索的列上，可以加快搜索的速度；
- 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
- 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；
- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；
- 避免 where 子句中对宇段施加函数，这会造成无法命中索引。
- 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- 删除长期未使用的索引

5.对sql语句进行优化
- SQL语句中IN包含的值不应过多
- SELECT语句务必指明字段名称
- 只查询一条数据的时候，使用limit 1
- 避免在where子句中对字段进行null值判断: 对于null的判断会导致引擎放弃使用索引而进行全表扫描。mysql会自动判断数据的分布情况，判断数据中 null 多还是 not null 多, 然后决定走不走索引. 
- 避免在where子句中对字段进行表达式操作
- 对于联合索引来说，要遵守最左前缀法则
- 尽量使用inner join，避免left join：如果连接方式是inner join，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是left join在驱动表的选择上遵循的是左边驱动右边的原则，即left join左边的表名为驱动表（所以如果要使用left join，则要小表驱动大表）。
- 注意范围查询语句: 对于联合索引来说，如果存在范围查询，比如between、>、<等条件时，会造成后面的索引字段失效。解决办法: 业务允许的情况下,使用 >= 或者<=  这样不影响索引的使用. 当Mysql发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描。
- 不建议使用%前缀模糊查询:例如 : LIKE“%name”或者LIKE“%name%”，这种查询会导致索引失效而进行全表扫描。但是可以使用LIKE “name%”。
- 在 where 子句中使用 or 来连接条件，如果or连接的条件有一方没有索引,将导致引擎放弃使用索引而进行全表扫描。解决办法: 将or连接的双方都建立索引,就可以使用. 
- 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。(此处存在疑点,测试的时候,发现索引还是能使用到)
- 字符串类型的字段 查询的时候如果不加引号''  ,会导致自动进行隐式转换,然后索引失效
- 指定查询的索引，当sql查询的字段有多个索引的时候,mysql优化器会自动选择一个索引进行查询,我们也可以通过sql字段进行自定义

6.其他优化
- 需要插入多条数据的时候 使用批量插入.(多次插入需要频繁的建立连接.浪费资源) 
- 多次插入数据时,采用手动提交事务
- order by 排序优化 (排序时,使用有索引的字段进行排序) 
- count 优化，速度:count(*)>count(1)>count(字段)，count( * ):inndb引擎,特意做了优化,不会取出值,直接服务层进行累加
- update优化  (避免出现表锁)，innodb引擎使用update时,会有行锁/表锁两种模式, 如果where 字段没有索引的时候会升级成表锁
- 创建表时使用同一的编码，mysql多表联查时,如果表的字符集不一样,会有一个数据类型转换的过程. 例如 utf8 与utf8mb4前者是3字节unicode编码，后者是4字节unicode编码. 此时如果多表查询,则索引会失效

**线上定位问题调试**

通过日志，做好日志打印，方便各种问题调试

**jvm参数调优**

1.jvm调优涉及到两个很重要的概念：吞吐量和响应时间。jvm调优主要是针对他们进行调整优化，达到一个理想的目标，根据业务确定目标是吞吐量优先还是响应时间优先。  
吞吐量：用户代码执行时间/(用户代码执行时间+GC执行时间)。  
响应时间：整个接口的响应时间(用户代码执行时间+GC执行时间)，stw时间越短，响应时间越短。  

调优的前提是熟悉业务场景，先判断出当前业务场景是吞吐量优先还是响应时间优先。调优需要建立在监控之上，由压力测来判断是否达到业务要求和性能要求。  调优的步骤大致可以分为：
- 熟悉业务场景，了解当前业务系统的要求，是吞吐量优先还是响应时间优先；
- 选择合适的垃圾回收器组合，如果是吞吐量优先，则选择ps+po组合；如果是响应时间优先，在1.8以后选择G1，在1.8之前选择ParNew+CMS组合；
- 规划内存需求，只能进行大致的规划。
- CPU选择，在预算之内性能越高越好；
- 根据实际情况设置升级年龄，最大年龄为15；
- 设定日志参数：-Xloggc:/path/name-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogs=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCauses
 
```txt
-XX:+UseGCLogFileRotation：GC文件循环使用
-XX:NumberOfGCLogs=5：使用5个GC文件
-XX:GCLogFileSize=20M：每个GC文件的大小
上面这三个参数放在一起代表的含义是：5个GC文件循环使用，每个GC文件20M，总共使用100M存储日志文件，当5个GC文件都使用完毕以后，覆盖第一个GC日志文件，生成新的GC文件。
```

2.对JVM内存的系统级的调优主要的目的是减少GC的频率和Full GC的次数。导致Full GC的原因一般是年老代（Tenured）被写满，调优时尽量让对象在新生代GC时被回收、让对象在新生代多存活一段时间和不要创建过大的对象及数组避免直接在年老代创建对象。
- 1.监控GC的状态
- 2.生成堆的dump文件，通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。
- 3.分析dump文件，Visual VM
- 分析结果，判断是否需要优化，如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化，如果GC时间超过1-3秒，或者频繁GC，则必须优化。

**垃圾收集器**

JDK8中默认的是UseParallelGC 即 Parallel Scavenge + Parallel Old

[参考资料](https://blog.csdn.net/xushiyu1996818/article/details/102761595)

**Serial 收集器**: 这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个CPU或一条收集线程去完成垃圾收 集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（这件事情称之为“Stop The World”），直到它收集结束.**新生代采用标记-复制算法，老年代采用标记-整理算法。**  
特点是简单而高效（与其他收集器的单线程比），对 于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收 集自然可以获得最高的单线程收集效率。

**ParNew 收集器**: ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数。**新生代采用标记-复制算法，老年代采用标记-整理算法。** 其中有一个与功能、性能无关但其实很重要的原因是:除了Serial收器外,目前只有它能与CMS收集器配合工作。自JDK 9开始，可以理解为ParNew合并入CMS,成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。

**Parallel Scavenge 收集器**: 
Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器， 又是并行的多线程收集器（**新生代采用标记-复制算法，老年代采用标记-整理算法。**）, Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目 标则是达到一个可控制的吞吐量(Throughput)。  
停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。  
由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量 优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参 数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就 不需要手工指定新生代的大小（・Xmn）、Eden与Survivor区的比例（・XX:SurvivorRatio）、 晋升老年代对象年龄（・XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当 前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或 最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）

**CMS收集器**: CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器，是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。从名字(包含“MarkSweep”)上就可以看出CMS收集器是基于“标记-清除”算 法实现的.

CMS运作过程:
- 初始标记(CMS initial mark)
- 并发标记(CMS concurrent mark)
- 并发预清理
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。

CMS是一款优秀的收集器，它的最主要优点在名字上已经体现出来了：并发收集、 低停顿，Sun的一些官方文档里面也称之为并发低停顿收集器(Concurrent Low Pause Collector)。但是CMS还远达不到完美的程度，它有以下四个显著的缺点：

- 对 CPU 资源敏感
- 无法处理浮动垃圾，可能会导致serial old
- 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生
- 需要预留的空间，给用户线程使用

**G1收集器**: G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.

作为CMS收集器的替代者和继承人,设计者们希望做出一款能够建立起“停顿时间模型” (PausePrediction Model)的收集器,停顿时间模型的意思是能够支持指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间大概率不超过N毫秒这样的目标,这几乎已经是实时Java (RTSJ)的中软实时垃圾收集器特征了。  
在G1收集器出现之前的所有其他收集器,包括CMS在内,垃圾收集的目标范围要么是整个新生代(Minor GC) ,要么就是整个老年代(Major GC) ,再要么就是整个Java堆(Full GC)。而G1跳出了这个樊笼,它可以面向堆内存任何部分来组成回收集(Collection Set,一般简称CSet)进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。

G1 收集器采用一种不同的方式来管理堆内存.堆内存被划分为多个大小相等的 heap 区,每个heap区都是逻辑上连续的一段内存(virtual memory). 其中一部分区域被当成收集器相同的角色(eden, survivor, old), 但每个角色的区域个数都不是固定的。这在内存使用上提供了更多的灵活性。

**ZGC收集器**: ZGC（The Z Garbage Collector）是JDK 11中推出的一款低延迟垃圾回收器，它的设计目标包括：
- 停顿时间不超过10ms；
- 停顿时间不会随着堆的大小，或者活跃对象的大小而增加；
- 支持8MB~4TB级别的堆（未来支持16TB）。
- 从设计目标来看，我们知道ZGC适用于大内存低延迟服务的内存管理和回收。
- 与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因。

**spring bean生命周期**

1. Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化（相当于程序中的new Xx()）
2. Bean实例化后对将Bean的引入和值注入到Bean的属性中
3. 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法(实现BeanNameAware接口主要是为了通过Bean的引用来获得Bean的ID，一般业务中是很少有用到Bean的ID的)
4. 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入（（实现BeanFactoryAware 主要目的是为了获取Spring容器，如Bean通过Spring容器发布事件等））
5. 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。（(作用与BeanFactory类似都是为了获取Spring容器，不同的是Spring容器在调用setApplicationContext方法时会把它自己作为setApplicationContext 的参数传入，而Spring容器在调用setBeanFactory前需要程序员自己指定（注入）setBeanFactory里的参数BeanFactory )
6. 如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessBeforeInitialization（预初始化）方法（作用是在Bean实例创建成功后对进行增强处理，如对Bean进行修改，增加某个功能）
7. 如果Bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet方法，作用与在配置文件中对Bean使用init-method声明初始化的作用一样，都是在Bean的全部属性设置成功后执行的初始化方法。
8. 如果Bean实现了BeanPostProcess接口，Spring将调用它们的postProcessAfterInitialization（后初始化）方法（作用与6的一样，只不过6是在Bean初始化前执行的，而这个是在Bean初始化后执行的，时机不同 )
9. 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。
10. 如果Bean实现了DisposableBean接口接口，Spring将调用它的destroy方法，作用与在配置文件中对Bean使用destroy-method属性的作用一样，都是在Bean实例销毁前执行的方法。


**spring mvc流程**

1. 前端向服务器发送请求，请求被 Spring 前端控制Servlet DispatcherServlet(中央处理器)捕获；
2. DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回给DispatcherServlet(中央处理器)；
3. DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）
4. 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：  
HttpMessageConverter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息数据转换：对请求消息进行数据转换。如String转换成Integer、Double等数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中.
5. Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；
6. 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；
7. ViewResolver 结合Model和View，来渲染视图
8. 将渲染结果返回给客户端。

ioc和aop


**spring事物传播特性**

事务的传播，是指一个方法调用另一个方法并将事务传递给它。事务的转播机制主要针对被调用者而言，控制它是否被传播或者被怎样传播。spring事务的传播机制有七种:

| 传播行为                  | 描述                                                                                                                              |
| :------------------------ | :-------------------------------------------------------------------------------------------------------------------------------- |
| PROPAGATION_REQUIRED      | 默认的Spring事物传播级别，若当前存在事务，则加入该事务，若不存在事务，则新建一个事务                                              |
| PROPAGATION_REQUIRE_NEW   | 若当前没有事务，则新建一个事务。若当前存在事务，则新建一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交 |
| PROPAGATION_NESTED        | 如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务，类似于REQUIRE_NEW                                    |
| PROPAGATION_SUPPORTS      | 支持当前事务，若当前不存在事务，以非事务的方式执行                                                                                |
| PROPAGATION_NOT_SUPPORTED | 以非事务的方式执行，若当前存在事务，则把当前事务挂起                                                                              |
| PROPAGATION_MANDATORY     | 强制事务执行，若当前不存在事务，则抛出异常                                                                                        |
| PROPAGATION_NEVER         | 以非事务的方式执行，如果当前存在事务，则抛出异常                                                                                  |

**找出热点缓存数据**

在业务表中增加一个字段，查询一次标记一次，次数到达一定值之后作为热点数据，在业务逻辑中处理。


30w数据，每个数据30个标签，需要筛选，怎么设计表


大对象变小如何存入redis


Kafka和rabbit分别实现多消费者


项目难点


多线程参数，超时时间


延时任务用哪个线程池

spring cloud Alibaba套件


open feign


负载均衡

说一下spring boot


面试题笔试题回答上来的有大概以下:谈一谈OOP，详细说一下数据类型，谈一谈继承、多态，谈一谈接口和抽象类的区别，三目运算符，
说一下六个设计原则，说几个会的设计模式及应用场景，手写单例模式（线程安全），手写冒泡排序、快速排序，聊一聊集合框架（问的很多，涉及底层实现），
手写实现文件的复制，介绍一下多线程（主要是不同的创建方式及其相关概念），Mysql相关概念及其优化（索引问得多），Servlet生命周期，jsp的9个内置对象，
filter的配置及应用，Spring的IOC和DI，AOP，Struts2、Spring、SpringMVC的工作流程及其配置文件，Spring及Spring boot的相关注解，
MyBatis和Hibernate的不同点及各自优缺点。以上是知识点，临场表达能力就靠自己了。        
以下是没有回答上来的：谈一谈JVM，笛卡儿积，红黑树的实现，nio（回答成了N/IO，丢脸），Linux搜索空文件夹并在每个文件夹中创建制定文件，
Sql语句也有很多写不出来，前端框架会多少，还有其他的记不住了。


喜欢那些新技术